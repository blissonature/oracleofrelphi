<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Planetary Hours</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#11151a; --muted:#96a1b0; --text:#e9eef5; --ring:#263244;
      --chip:#1a2028; --accent:#7aa2ff; --ok:#59d69e; --warn:#ffd166; --bad:#ef6b73;
      --saturn:#c0b28a; --sun:#ffb100; --moon:#c9d6ff; --mars:#ff6b6b; --mercury:#8bd3ff; --jupiter:#9dde7a; --venus:#ff9ad1;
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial,Apple Color Emoji,Segoe UI Emoji;}
    .wrap{max-width:1100px;margin:0 auto;padding:20px;}
    h1{font-size:28px;margin:0 0 6px}
    .sub{color:var(--muted);font-size:13px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .card{background:var(--panel);border:1px solid var(--ring);border-radius:14px;padding:14px;margin-top:12px}
    button,select,input{background:var(--chip);border:1px solid var(--ring);color:var(--text);border-radius:10px;padding:8px 10px}
    button.primary{background:var(--accent);border-color:transparent;color:#0b0d10;font-weight:600}
    .pill{display:inline-flex;align-items:center;gap:6px;background:var(--chip);border:1px solid var(--ring);border-radius:999px;padding:6px 10px;font-size:13px}
    .tiny{font-size:12px;color:var(--muted)}
    .hr-badge{font-size:11px;padding:2px 6px;border-radius:6px;border:1px solid var(--ring);background:#0f1318;color:var(--muted)}
    .ticker{position:relative;height:12px;background:#0e1319;border:1px solid var(--ring);border-radius:999px;overflow:hidden}
    .tick-bar{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg,var(--accent),#94b6ff)}
    .tick-marker{position:absolute;top:-6px;bottom:-6px;width:2px;background:var(--ring)}
    .now-row{background:#0e141b;border:1px solid #2b3a4f}
    table{width:100%;border-collapse:separate;border-spacing:0 6px}
    th,td{font-size:13px;padding:10px}
    thead th{position:sticky;top:0;background:var(--panel);z-index:1;border-bottom:1px solid var(--ring)}
    tbody tr{background:#0e141b;border:1px solid var(--ring)}
    tbody tr.now{outline:2px solid var(--accent);}
    .flex-between{display:flex;justify-content:space-between;align-items:center}
    .mono{font-variant-numeric:tabular-nums;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .side-pills{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center}
    .side-left{justify-self:start}
    .side-right{justify-self:end}
    .center-block{display:grid;gap:6px;justify-items:center}
    .legend{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    .matrix{overflow:auto}
    .matrix table td{white-space:nowrap}
    .testbar{display:flex;gap:8px;align-items:center}
    .warn{color:var(--warn)}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Header -->
    <div class="card" id="header">
      <div class="flex-between">
        <div>
          <h1>Planetary Hours</h1>
          <div class="sub">Single-file app â€¢ sunrise â†’ sunrise</div>
        </div>
        <div class="row">
          <div class="mono" id="liveClock">--:--</div>
          <button id="copyLinkBtn" class="primary" aria-describedby="copyStatus">Copy link to this view</button>
          <span id="copyStatus" class="tiny" aria-live="polite"></span>
        </div>
      </div>
    </div>

    <!-- Location & Time Controls -->
    <div class="card" id="controls">
      <div class="row" id="locRow">
        <button id="useGeo">Use my location</button>
        <select id="tzSelect"></select>
        <input id="latInput" class="mono" placeholder="Lat" size="10" />
        <input id="lonInput" class="mono" placeholder="Lon" size="10" />
        <button id="setLatLon">Set</button>
        <div class="tiny mono" id="locEcho">â€”</div>
      </div>
      <div class="row" id="dtRow" style="margin-top:8px">
        <label class="row" style="gap:6px">
          <input type="checkbox" id="useSystem" checked /> Use system date/time
        </label>
        <input type="date" id="datePick" disabled />
        <input type="time" id="timePick" disabled />
        <button id="applyDt" disabled>Apply</button>
        <div class="tiny">Day runs sunrise â†’ sunrise.</div>
      </div>
      <div class="row" id="modeRow" style="margin-top:8px">
        <label>Mode:</label>
        <select id="modeSelect">
          <option value="sidereal">Sidereal</option>
          <option value="ratio">Ratio</option>
          <option value="hybrid">Hybrid</option>
        </select>
      </div>
    </div>

    <!-- Day Summary -->
    <div class="card" id="summary">
      <div class="row" id="dayRulerPill">â€”</div>
      <div class="row" style="margin-top:8px">
        <div class="pill">Sunrise <span class="mono" id="sunrise">--:--</span></div>
        <div class="pill">Sunset <span class="mono" id="sunset">--:--</span></div>
        <div class="pill">Next Sunrise <span class="mono" id="nextSunrise">--:--</span></div>
        <div class="pill" id="bridgeLine">Bridge: â€”</div>
        <div class="tiny warn" id="polarNotice" hidden>Sun never rises/sets for this date/location. Matrix & bridges remain available.</div>
      </div>
    </div>

    <!-- Current Hour Band (Hero) -->
    <div class="card" id="hero">
      <div class="ticker" id="ticker">
        <div class="tick-bar" id="tickBar"></div>
        <div class="tick-marker" id="markStart"></div>
        <div class="tick-marker" id="markSunset"></div>
        <div class="tick-marker" id="markEnd"></div>
      </div>
      <!-- (per request) no time labels under the progress bar -->
      <div class="side-pills" style="margin-top:10px">
        <div class="pill side-left" id="nextPill">Next: â€”</div>
        <div class="center-block">
          <div class="pill" id="currentPill">Current: â€”</div>
          <div style="font-size:22px" class="mono" id="multiplier">x0.000</div>
          <div class="tiny mono" id="formulaLine">Power = (day Ã— hour) Ã— (1/ordinal) + ordinal â€¢ <span id="ordinalChip">â€”</span></div>
          <div class="tiny mono" id="metaLine">Hour â€”/24 â€¢ â€” â€¢ Ruler appearance: â€” of 24 today â€¢ Hours ruled B/D/T: â€”</div>
          <div class="tiny mono" id="approachLine">â€”</div>
          <div class="legend" id="legendChips"></div>
        </div>
        <div class="pill side-right" id="prevPill">Prev: â€”</div>
      </div>
    </div>

    <!-- 24-Hour Table -->
    <div class="card" id="hourTableCard">
      <div class="flex-between"><h2 style="margin:0;font-size:18px">24-Hour Table</h2></div>
      <div style="overflow:auto">
        <table id="hourTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Startâ€“End</th>
              <th>Ruler</th>
              <th>Order</th>
              <th>Hour</th>
              <th>Hours ruled (B/D/T)</th>
              <th>Multiplier</th>
              <th>Focus</th>
            </tr>
          </thead>
            <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- 7Ã—7 Focus Matrix -->
    <div class="card" id="matrixCard">
      <div class="flex-between">
        <h2 style="margin:0;font-size:18px">7Ã—7 Focus Matrix</h2>
        <div class="row"><label>Filter:</label>
          <select id="matrixFilter">
            <option value="all">All</option>
            <option value="bright">Bright</option>
            <option value="dark">Dark</option>
          </select>
        </div>
      </div>
      <div class="matrix" style="margin-top:8px">
        <table id="matrixTable"><tbody></tbody></table>
      </div>
    </div>

    <!-- Weekly Bridge Hours -->
    <div class="card" id="bridgesCard">
      <h2 style="margin:0 0 8px;font-size:18px">Weekly Bridge Hours</h2>
      <div style="overflow:auto">
        <table id="bridgesTable">
          <thead>
            <tr>
              <th>Day (last hr)</th>
              <th>Multiplier</th>
              <th>Next day (first hr)</th>
              <th>Multiplier</th>
              <th>Î”</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- Help / Tests -->
    <div class="card">
      <details>
        <summary>ðŸ”§ Built-in tests</summary>
        <div class="testbar" style="margin-top:8px">
          <button id="runTestsBtn">Run tests</button>
          <div id="testOut" class="tiny mono"></div>
        </div>
      </details>
    </div>
  </div>

  <script>
  // ----------------------------
  //  Planet & Utility Constants
  // ----------------------------
  const PLANETS = [
    {key:'saturn',  symbol:'\u2644', name:'Saturn',  color:'var(--saturn)',  weight:29.46, focusDay:'Structure â€¢ boundaries', focusHour:'Discipline â€¢ consolidation'},
    {key:'jupiter', symbol:'\u2643', name:'Jupiter', color:'var(--jupiter)', weight:11.86, focusDay:'Growth â€¢ benevolence',   focusHour:'Opportunity â€¢ expansion'},
    {key:'mars',    symbol:'\u2642', name:'Mars',    color:'var(--mars)',    weight:1.88,  focusDay:'Courage â€¢ severance',   focusHour:'Action â€¢ cutting'},
    {key:'sun',     symbol:'\u2609', name:'Sun',     color:'var(--sun)',     weight:1.00,  focusDay:'Vitality â€¢ presence',   focusHour:'Clarity â€¢ expression'},
    {key:'venus',   symbol:'\u2640', name:'Venus',   color:'var(--venus)',   weight:0.615, focusDay:'Harmony â€¢ attraction',  focusHour:'Relating â€¢ pleasure'},
    {key:'mercury', symbol:'\u263f', name:'Mercury', color:'var(--mercury)', weight:0.241, focusDay:'Signals â€¢ trade',       focusHour:'Analysis â€¢ message'},
    {key:'moon',    symbol:'\u263e', name:'Moon',    color:'var(--moon)',    weight:0.0748,focusDay:'Rhythm â€¢ care',         focusHour:'Reflection â€¢ flux'},
  ];
  const ORDER = ['saturn','jupiter','mars','sun','venus','mercury','moon']; // Chaldean
  const DAY_RULERS = ['sun','moon','mars','mercury','jupiter','venus','saturn']; // Sun..Sat
  const fmtHM = d=> new Intl.DateTimeFormat([], {hour:'2-digit', minute:'2-digit'}).format(d);
  const clamp = (n,min,max)=> Math.min(max, Math.max(min,n));
  const ORDINALS = [null,'1st (Prime)','2nd (Octave)','3rd (Fifth)','4th (Fourth)','5th (Third)','6th','7th','8th','9th','10th','11th','12th','13th','14th','15th','16th','17th','18th','19th','20th','21st','22nd','23rd','24th'];

  // ----------------------------
  //  Global State
  // ----------------------------
  const S = {
    lat: 40.7608,
    lon: -111.8910,
    tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
    mode: 'sidereal',
    useSystem: true,
    dt: new Date(),
    frame: null,
    hours: [],
    tickRAF: null,
  };

  // ----------------------------
  //  Init
  // ----------------------------
  window.addEventListener('DOMContentLoaded', () => {
    bindUI();
    loadFromHash();
    populateTimezones();
    startLiveClock();
    rebuild();
    window.addEventListener('resize', onResize, {passive:true});
  });

  function bindUI(){
    byId('copyLinkBtn').addEventListener('click', copyLink);
    byId('useGeo').addEventListener('click', useGeolocation);
    byId('setLatLon').addEventListener('click', ()=>{
      const lat = parseFloat(byId('latInput').value);
      const lon = parseFloat(byId('lonInput').value);
      if(Number.isFinite(lat) && Number.isFinite(lon)){
        S.lat = clamp(lat, -90, 90);
        S.lon = ((lon+540)%360)-180; // wrap
        saveToHash();
        rebuild();
      } else note('Invalid lat/lon');
    });
    byId('tzSelect').addEventListener('change', e=>{ S.tz = e.target.value; saveToHash(); rebuild(); });
    byId('modeSelect').addEventListener('change', e=>{ S.mode = e.target.value; saveToHash(); rebuild(); });

    const useSystem = byId('useSystem');
    const datePick = byId('datePick');
    const timePick = byId('timePick');
    const applyDt  = byId('applyDt');
    useSystem.addEventListener('change', ()=>{
      const on = useSystem.checked;
      datePick.disabled = timePick.disabled = applyDt.disabled = on;
      S.useSystem = on;
      if(on){ S.dt = new Date(); saveToHash(); rebuild(); }
    });
    applyDt.addEventListener('click', ()=>{
      const dp = datePick.value; const tp = timePick.value || '00:00';
      if(!dp){ note('Pick a date/time'); return; }
      const [y,m,d] = dp.split('-').map(Number);
      const [hh,mm] = tp.split(':').map(Number);
      S.dt = fromLocalPartsInTZ(y, m-1, d, hh, mm, 0, S.tz);
      S.useSystem = false; byId('useSystem').checked = false;
      saveToHash(); rebuild();
    });

    const runBtn = byId('runTestsBtn'); if(runBtn){ runBtn.addEventListener('click', runTests); }
  }

  function onResize(){ layoutTickerMarkers(); }

  function startLiveClock(){
    const el = byId('liveClock');
    function tick(){ el.textContent = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); requestAnimationFrame(()=>setTimeout(tick, 600)); }
    tick();
  }

  // ----------------------------
  //  Timezone helpers
  // ----------------------------
  function tzOffsetMinutes(date, timeZone){
    const dtf = new Intl.DateTimeFormat('en-US', {
      timeZone, hour12:false,
      year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit'
    });
    const parts = dtf.formatToParts(date); const map={}; parts.forEach(p=>map[p.type]=p.value);
    const asUTC = Date.UTC(map.year, map.month-1, map.day, map.hour, map.minute, map.second);
    return (asUTC - date.getTime())/60000;
  }
  function fromLocalPartsInTZ(y,m,d,hh,mm,ss,timeZone){
    const utcGuess = Date.UTC(y,m,d,hh,mm,ss);
    const guess = new Date(utcGuess);
    const off = tzOffsetMinutes(guess, timeZone);
    return new Date(utcGuess - off*60000);
  }
  function toLocalPartsInTZ(date, timeZone){
    const dtf = new Intl.DateTimeFormat('en-US', {timeZone, hour12:false,year:'numeric', month:'2-digit', day:'2-digit',hour:'2-digit', minute:'2-digit', second:'2-digit'});
    const parts = dtf.formatToParts(date); const map={}; parts.forEach(p=>map[p.type]=p.value);
    return { y:+map.year, m:+map.month, d:+map.day, hh:+map.hour, mm:+map.minute, ss:+map.second };
  }

  // ----------------------------
  //  State <-> Hash (always include dt; add sys flag)
  // ----------------------------
  function saveToHash(){
    const o = { lat:S.lat.toFixed(4), lon:S.lon.toFixed(4), tz:S.tz, mode:S.mode };
    const parts = toLocalPartsInTZ(S.dt, S.tz);
    const dtStr = `${parts.y}-${String(parts.m).padStart(2,'0')}-${String(parts.d).padStart(2,'0')}T${String(parts.hh).padStart(2,'0')}:${String(parts.mm).padStart(2,'0')}`;
    o.dt = dtStr; if(S.useSystem) o.sys = '1';
    const hash = new URLSearchParams(o).toString();
    location.hash = hash;
  }
  function loadFromHash(){
    const h = new URLSearchParams(location.hash.slice(1));
    if(h.has('lat')) S.lat = parseFloat(h.get('lat'));
    if(h.has('lon')) S.lon = parseFloat(h.get('lon'));
    if(h.has('tz'))  S.tz  = h.get('tz');
    if(h.has('mode'))S.mode= h.get('mode');
    if(h.has('dt')){
      const [dts, tts] = h.get('dt').split('T');
      const [y,m,d] = dts.split('-').map(Number);
      const [hh,mm] = (tts||'00:00').split(':').map(Number);
      S.dt = fromLocalPartsInTZ(y, m-1, d, hh, mm, 0, S.tz);
    }
    S.useSystem = h.get('sys')==='1';

    byId('latInput').value = S.lat.toFixed(4);
    byId('lonInput').value = S.lon.toFixed(4);
    byId('modeSelect').value = S.mode;
    byId('useSystem').checked = S.useSystem;
    byId('datePick').disabled = byId('timePick').disabled = byId('applyDt').disabled = S.useSystem;
    const parts = toLocalPartsInTZ(S.dt, S.tz);
    if(!S.useSystem){
      byId('datePick').value = `${parts.y}-${String(parts.m).padStart(2,'0')}-${String(parts.d).padStart(2,'0')}`;
      byId('timePick').value = `${String(parts.hh).padStart(2,'0')}:${String(parts.mm).padStart(2,'0')}`;
    }
  }

  function buildShareURL(){ saveToHash(); return location.origin + location.pathname + location.search + '#' + location.hash.slice(1); }

  async function copyLink(){
    const url = buildShareURL();
    try{
      if(navigator.clipboard && window.isSecureContext){ await navigator.clipboard.writeText(url); }
      else{
        const ta=document.createElement('textarea'); ta.value=url; ta.setAttribute('readonly',''); ta.style.position='fixed'; ta.style.opacity='0';
        document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      }
      flashStatus('Link copied!', 1400);
    }catch(e){ flashStatus('Copy failed. Select URL bar to copy.', 3000, true); }
  }
  function flashStatus(msg, ms=1200, isWarn=false){
    const status = byId('copyStatus'); if(!status) return;
    status.textContent = msg; status.style.color = isWarn? 'var(--warn)' : 'var(--muted)';
    const btn = byId('copyLinkBtn'); const orig = btn.textContent; btn.disabled = true; btn.textContent = 'Copied!';
    setTimeout(()=>{ status.textContent=''; btn.disabled=false; btn.textContent = orig; }, ms);
  }

  // ----------------------------
  //  Astronomy (accurate sun times)
  // ----------------------------
  function toRadians(deg){ return deg*Math.PI/180; } function toDegrees(rad){ return rad*180/Math.PI; } function normalizeAngle(a){ return (a%360 + 360)%360; }
  function solarDeclination(L){ const e = 23.4397; return toDegrees(Math.asin(Math.sin(toRadians(e)) * Math.sin(toRadians(L)))); }
  function equationOfTime(M, L){
    const e = 0.0167086; const epsilon = toRadians(23.4397); const y = Math.tan(epsilon/2); const y2 = y*y;
    return toDegrees(y2*Math.sin(2*toRadians(L)) - 2*e*Math.sin(toRadians(M)) + 4*e*y2*Math.sin(toRadians(M))*Math.cos(2*toRadians(L)) - 0.5*y2*y2*Math.sin(4*toRadians(L)) - 1.25*e*e*Math.sin(2*toRadians(M))) * 4;
  }
  function sunGeom(dayOfYear){ const M = normalizeAngle(357.5291 + 0.98560028 * (dayOfYear-1)); const C = 1.9148*Math.sin(toRadians(M)) + 0.0200*Math.sin(toRadians(2*M)) + 0.0003*Math.sin(toRadians(3*M)); const L = normalizeAngle(280.46646 + 0.98564736*(dayOfYear-1) + C); return {M, L}; }
  function hourAngle(lat, decl){
    const alt = -0.833;
    const cosH = (Math.sin(toRadians(alt)) - Math.sin(toRadians(lat))*Math.sin(toRadians(decl))) / (Math.cos(toRadians(lat))*Math.cos(toRadians(decl)));
    if(cosH < -1) return {polar:'midnight-sun'};
    if(cosH > 1)  return {polar:'polar-night'};
    return {H: toDegrees(Math.acos(cosH))};
  }
  function dayOfYearTZ(date, timeZone){
    const parts = toLocalPartsInTZ(date, timeZone);
    const d0 = fromLocalPartsInTZ(parts.y, 0, 1, 0, 0, 0, timeZone);
    return Math.floor((fromLocalPartsInTZ(parts.y, parts.m-1, parts.d, 12, 0, 0, timeZone) - d0)/86400000)+1;
  }
  function computeSunTimesLocal(date, lat, lon, timeZone){
    const doy = dayOfYearTZ(date, timeZone);
    const {M, L} = sunGeom(doy);
    const decl = solarDeclination(L);
    const ha = hourAngle(lat, decl);
    if(ha.polar) return { polar: true };
    const EoT = equationOfTime(M, L);
    const tzOffMin = tzOffsetMinutes(date, timeZone);
    const solarNoonMin = 720 - 4*lon - EoT + tzOffMin;
    const deltaMin = 4 * ha.H;
    const parts = toLocalPartsInTZ(date, timeZone);
    const base = fromLocalPartsInTZ(parts.y, parts.m-1, parts.d, 0, 0, 0, timeZone);
    const sunriseLocal = new Date(base.getTime() + (solarNoonMin - deltaMin)*60000);
    const sunsetLocal  = new Date(base.getTime() + (solarNoonMin + deltaMin)*60000);
    return { sunriseLocal, sunsetLocal, polar:false };
  }

  // ----------------------------
  //  FIXED Frame computation
  //     - if now < todayâ€™s sunrise: frame = [yesterday sunrise .. today sunrise]
  //       and sunset = yesterdayâ€™s sunset  âœ…
  // ----------------------------
  function computeFrameAccurate(now, lat, lon, timeZone){
    const { y, m, d, hh, mm } = toLocalPartsInTZ(now, timeZone);
    const todayNoon = fromLocalPartsInTZ(y, m-1, d, 12, 0, 0, timeZone);
    const yesterdayNoon = new Date(todayNoon.getTime() - 86400000);
    const tomorrowNoon  = new Date(todayNoon.getTime() + 86400000);

    const yTimes = computeSunTimesLocal(yesterdayNoon, lat, lon, timeZone);
    const tTimes = computeSunTimesLocal(todayNoon,     lat, lon, timeZone);
    if(yTimes.polar || tTimes.polar){
      return {
        start: todayNoon,
        end: new Date(todayNoon.getTime()+86400000),
        sunrise: todayNoon, sunset: todayNoon, nextSunrise: new Date(todayNoon.getTime()+86400000),
        dayRulerKey: DAY_RULERS[fromLocalPartsInTZ(y,m-1,d,0,0,0,timeZone).getDay()],
        polar:true
      };
    }
    const sr0 = yTimes.sunriseLocal, ss0 = yTimes.sunsetLocal;
    const sr1 = tTimes.sunriseLocal, ss1 = tTimes.sunsetLocal;
    const sr2 = computeSunTimesLocal(tomorrowNoon, lat, lon, timeZone).sunriseLocal;

    const nowLocal = fromLocalPartsInTZ(y, m-1, d, hh, mm, 0, timeZone);

    let start, end, sunsetForFrame;
    if(nowLocal >= sr1){
      start = sr1; end = sr2; sunsetForFrame = ss1;
    } else {
      start = sr0; end = sr1; sunsetForFrame = ss0; // <-- crucial fix
    }

    const dayRulerKey = DAY_RULERS[start.getDay()];
    return { start, end, sunrise:sr1, sunset:sunsetForFrame, nextSunrise:end, dayRulerKey, polar:false };
  }

  // ----------------------------
  //  Hour Blocks & Multipliers
  // ----------------------------
  function buildHourBlocks(frame){
    const blocks=[];
    const dayLenMs = frame.sunset - frame.start;
    const nightLenMs = frame.end - frame.sunset;
    const dayStep = dayLenMs/12, nightStep = nightLenMs/12;

    const startIdx = ORDER.indexOf(frame.dayRulerKey);
    const seq = Array.from({length:24}, (_,i)=> ORDER[(startIdx + i)%ORDER.length]);

    for(let i=0;i<24;i++){
      const isBright = i<12;
      const start = new Date(isBright ? (frame.start.getTime() + i*dayStep) : (frame.sunset.getTime() + (i-12)*nightStep));
      const end   = new Date(isBright ? (frame.start.getTime() + (i+1)*dayStep) : (frame.sunset.getTime() + (i-11)*nightStep));
      blocks.push({ idx:i+1, ordinal:i+1, isBright, start, end, ruler: seq[i] });
    }
    const counts = Object.fromEntries(ORDER.map(k=>[k,{B:0,D:0,T:0}]));
    blocks.forEach(b=>{ const c=counts[b.ruler]; if(b.isBright) c.B++; else c.D++; c.T++; });
    blocks.forEach(b=>{ b.counts = counts[b.ruler]; });
    return blocks;
  }

  function weightFor(key){ return PLANETS.find(p=>p.key===key).weight; }

  function computeMultipliers(){
    const mode = S.mode;
    S.hours.forEach(b=>{
      const dayW = weightFor(S.frame.dayRulerKey);
      const hrW  = weightFor(b.ruler);
      const sidereal = (dayW * hrW) * (1/b.ordinal) + b.ordinal;
      const ratio = (b.counts.T/24) * 10;
      const hybrid = sidereal * ratio;
      b.mult = mode==='sidereal'?sidereal: mode==='ratio'?ratio: hybrid;
    });
  }

  // ----------------------------
  //  Rendering
  // ----------------------------
  function renderSummary(){
    const dr = PLANETS.find(p=>p.key===S.frame.dayRulerKey);
    byId('dayRulerPill').innerHTML = `<span class="pill" style="border-color:${dr.color}">${dr.symbol} <strong>${dr.name}</strong> â€¢ weight ${dr.weight} â€¢ ${dr.focusDay}</span>`;
    byId('sunrise').textContent = S.frame.polar? 'N/A' : fmtHM(S.frame.sunrise);
    byId('sunset').textContent = S.frame.polar? 'N/A' : fmtHM(S.frame.sunset);
    byId('nextSunrise').textContent = S.frame.polar? 'N/A' : fmtHM(S.frame.nextSunrise);
    byId('locEcho').textContent = `${S.lat.toFixed(4)}, ${S.lon.toFixed(4)} (${S.tz})`;
  }

  function renderHero(){
    const now = S.useSystem? new Date(): S.dt;

    // Normal detection
    let iNow = S.hours.findIndex(h=> now>=h.start && now<h.end);

    // Edge: if we've slipped past hour 23 end but before next sunrise,
    // clamp to hour 24 display.
    if(iNow === -1 && now >= S.hours[23].end && now < S.frame.end){
      iNow = 23;
    }
    const curr = S.hours[ clamp(iNow,0,23) ];
    const prev = S.hours[ (curr.idx-2+24)%24 ];
    const next = S.hours[ (curr.idx)%24 ];

    const pr = PLANETS.find(p=>p.key===prev.ruler);
    const cr = PLANETS.find(p=>p.key===curr.ruler);
    const nx = PLANETS.find(p=>p.key===next.ruler);

    byId('currentPill').innerHTML = `${cr.symbol} <strong>${cr.name}</strong>`;
    byId('prevPill').innerHTML = `Prev: ${pr.symbol} ${pr.name} â€¢ ends ${fmtHM(prev.end)}`;
    byId('nextPill').innerHTML = `Next: ${nx.symbol} ${nx.name} â€¢ starts ${fmtHM(next.start)}`;

    byId('multiplier').textContent = 'x' + curr.mult.toFixed(3);
    byId('ordinalChip').textContent = ORDINALS[curr.ordinal]||(`${curr.ordinal}th`);
    const bd = curr.isBright? 'Bright' : 'Dark';
    byId('metaLine').textContent = `Hour ${curr.idx}/24 â€¢ ${bd} â€¢ Ruler appearance: ${curr.counts.T} of 24 today â€¢ Hours ruled B/D/T: ${curr.counts.B}/${curr.counts.D}/${curr.counts.T}`;

    // Approaching sunrise line
    const nextDayRulerKey = DAY_RULERS[(S.frame.start.getDay()+1)%7];
    const nextDay = PLANETS.find(p=>p.key===nextDayRulerKey);
    byId('approachLine').textContent = (curr.idx===24)
      ? `Approaching sunrise â†’ ${nextDay.symbol} ${nextDay.name} day`
      : `Next sunrise â†’ ${nextDay.symbol} ${nextDay.name} day`;

    // Legend chips
    const dr = PLANETS.find(p=>p.key===S.frame.dayRulerKey);
    byId('legendChips').innerHTML = `
      <span class="pill" style="border-color:${dr.color}">${dr.symbol} ${dr.name} â€” ${dr.focusDay}</span>
      <span class="pill" style="border-color:${cr.color}">${cr.symbol} ${cr.name} â€” ${cr.focusHour}</span>
    `;

    // Bridge Î”
    const h24 = S.hours[23], h1 = S.hours[0];
    const delta = h1.mult - h24.mult; const arrow = delta>0? 'â†‘' : delta<0? 'â†“' : 'â†’';
    byId('bridgeLine').textContent = `${PLANETS.find(p=>p.key===h24.ruler).symbol} ${cap(h24.ruler)} (Hour 24) â†’ ${PLANETS.find(p=>p.key===h1.ruler).symbol} ${cap(h1.ruler)} (Hour 1) Î” ${delta>=0?'+':''}${delta.toFixed(3)} ${arrow}`;

    layoutTickerMarkers();
  }

  function layoutTickerMarkers(){
    const {start, sunset, end} = S.frame;
    const el = byId('ticker'); const W = el.clientWidth;
    const total = end - start;
    const pos = t => Math.max(0, Math.min(W, ( (t-start)/total ) * W ));
    byId('markStart').style.left = '0px';
    byId('markSunset').style.left = pos(sunset)+'px';
    byId('markEnd').style.left = (W-2)+'px';
  }

  function startTicker(){
    const {start, end} = S.frame;
    const bar = byId('tickBar');
    function step(){
      const now = S.useSystem? new Date(): S.dt;
      const p = clamp((now - start)/(end - start), 0, 1);
      bar.style.width = (p*100)+'%';
      S.tickRAF = requestAnimationFrame(step);
    }
    step();
  }
  function stopTicker(){ if(S.tickRAF){ cancelAnimationFrame(S.tickRAF); S.tickRAF=null; } }

  function renderHourTable(){
    const tb = byId('hourTable').querySelector('tbody'); tb.innerHTML='';
    const now = S.useSystem? new Date(): S.dt;
    S.hours.forEach(h=>{
      const tr = document.createElement('tr');
      if(now>=h.start && now<h.end) tr.classList.add('now');
      const ruler = PLANETS.find(p=>p.key===h.ruler);
      const order = ORDINALS[h.ordinal]||(`${h.ordinal}th`);
      const bd = h.isBright? '<span class="hr-badge">Bright</span>' : '<span class="hr-badge">Dark</span>';
      const focus = `${PLANETS.find(p=>p.key===S.frame.dayRulerKey).focusDay} Ã— ${ruler.focusHour}`;
      tr.innerHTML = `
        <td class="mono">${h.idx} ${bd}</td>
        <td class="mono">${fmtHM(h.start)} â€“ ${fmtHM(h.end)}</td>
        <td><span class="pill" style="border-color:${ruler.color}">${ruler.symbol} ${ruler.name}</span></td>
        <td class="mono">${order}</td>
        <td class="mono">${h.idx}/24</td>
        <td class="mono">${h.counts.B}/${h.counts.D}/${h.counts.T}</td>
        <td class="mono">x${h.mult.toFixed(3)}</td>
        <td>${focus}</td>`;
      tb.appendChild(tr);
    });
  }

  function renderMatrix(){
    const tb = byId('matrixTable').querySelector('tbody'); tb.innerHTML='';
    const dayCols = ['saturn','sun','moon','mars','mercury','jupiter','venus'];
    const head = document.createElement('tr');
    head.innerHTML = `<td></td>` + dayCols.map(k=>{
      const p= PLANETS.find(x=>x.key===k); return `<td><span class="pill" style="border-color:${p.color}">${p.symbol} ${p.name}</span></td>`;
    }).join('');
    tb.appendChild(head);

    ORDER.forEach((rk)=>{
      const rtr = document.createElement('tr');
      const rp = PLANETS.find(p=>p.key===rk);
      rtr.innerHTML = `<td><span class="pill" style="border-color:${rp.color}">${rp.symbol} ${rp.name}</span></td>`;
      rtr.innerHTML += dayCols.map(dk=>{
        const dp = PLANETS.find(p=>p.key===dk);
        const focus = `${dp.focusDay} Ã— ${rp.focusHour}`;
        return `<td title="${focus}"><span class="pill" style="border-color:${dp.color}">${dp.symbol}</span> <span class="tiny">${rp.name}</span></td>`;
      }).join('');
      tb.appendChild(rtr);
    });
  }

  function renderWeeklyBridges(){
    const tb = byId('bridgesTable').querySelector('tbody'); tb.innerHTML='';
    const base = new Date(S.frame.start);
    const startOfWeek = new Date(base); startOfWeek.setDate(base.getDate() - base.getDay()); // Sunday
    for(let d=0; d<7; d++){
      const dayStart = new Date(startOfWeek); dayStart.setDate(startOfWeek.getDate()+d);
      const frame = computeFrameAccurate(dayStart, S.lat, S.lon, S.tz);
      if(frame.polar){
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${weekdayName(dayStart)} â€” Polar</td><td colspan="4">N/A</td>`;
        tb.appendChild(tr); continue;
      }
      const hours = buildHourBlocks(frame);
      const modeKeep = S.mode;
      hours.forEach(b=>{
        const sid = (weightFor(frame.dayRulerKey)*weightFor(b.ruler))*(1/b.ordinal) + b.ordinal;
        const ratio = (hours.filter(x=>x.ruler===b.ruler).length/24)*10;
        b.mult = modeKeep==='sidereal'?sid: modeKeep==='ratio'?ratio: sid*ratio;
      });
      const h24 = hours[23], h1 = hours[0];
      const delta = h1.mult - h24.mult;
      const p24 = PLANETS.find(p=>p.key===h24.ruler), p1=PLANETS.find(p=>p.key===h1.ruler);
      const tr = document.createElement('tr');
      if(p24.key==='venus' && p1.key==='saturn') tr.style.outline = '2px solid var(--accent)';
      tr.innerHTML = `
        <td>${weekdayName(frame.start)} â€” ${p24.symbol} ${p24.name} (Hr 24)</td>
        <td class="mono">x${h24.mult.toFixed(3)}</td>
        <td>${weekdayName(new Date(frame.end))} â€” ${p1.symbol} ${p1.name} (Hr 1)</td>
        <td class="mono">x${h1.mult.toFixed(3)}</td>
        <td class="mono">${delta>=0?'+':''}${delta.toFixed(3)}</td>`;
      tb.appendChild(tr);
    }
  }

  // ----------------------------
  //  Geolocation & Timezones
  // ----------------------------
  function useGeolocation(){
    if(!navigator.geolocation){ note('Geolocation unavailable'); return; }
    navigator.geolocation.getCurrentPosition(pos=>{
      S.lat = pos.coords.latitude; S.lon = pos.coords.longitude;
      byId('latInput').value = S.lat.toFixed(4);
      byId('lonInput').value = S.lon.toFixed(4);
      saveToHash(); rebuild();
    }, err=> note('Geolocation denied'));
  }
  function populateTimezones(){
    const sel = byId('tzSelect'); sel.innerHTML='';
    const zones = (Intl.supportedValuesOf? Intl.supportedValuesOf('timeZone') : []).slice();
    const offs = []; for(let i=-12;i<=14;i++){ offs.push(`UTC${i>=0?'+':''}${i}:00`); }
    const opts = [...zones, ...offs]; opts.sort();
    for(const z of opts){ const o=document.createElement('option'); o.value=z; o.textContent=z; sel.appendChild(o); }
    sel.value = S.tz;
  }

  // ----------------------------
  //  Helpers & Rebuild
  // ----------------------------
  function byId(id){ return document.getElementById(id); }
  function note(msg){ console.warn(msg); }
  function cap(s){ return s.charAt(0).toUpperCase()+s.slice(1); }
  function weekdayName(d){ return new Intl.DateTimeFormat([], {weekday:'long'}).format(d); }

  function rebuild(){
    stopTicker();
    if(S.useSystem) S.dt = new Date();
    S.frame = computeFrameAccurate(S.dt, S.lat, S.lon, S.tz);
    renderSummary();
    if(S.frame.polar){
      byId('polarNotice').hidden = false;
      byId('hourTable').querySelector('tbody').innerHTML = '';
      byId('tickBar').style.width = '0%';
      byId('currentPill').textContent = 'N/A';
      renderMatrix(); renderWeeklyBridges();
      return;
    } else { byId('polarNotice').hidden = true; }
    S.hours = buildHourBlocks(S.frame);
    computeMultipliers();
    renderHero();
    renderHourTable();
    renderMatrix();
    renderWeeklyBridges();
    startTicker();
  }

  // ----------------------------
  //  Minimal Tests
  // ----------------------------
  function runTests(){
    const out = byId('testOut');
    try{
      const url = buildShareURL();
      if(!(typeof url==='string' && url.includes('#'))) throw new Error('URL with hash');
      const p = new URLSearchParams(location.hash.slice(1));
      if(!(p.has('dt') && p.has('tz') && p.has('mode'))) throw new Error('hash must include dt,tz,mode');

      // Acceptance #1: Before sunrise on Wednesday -> Mars day
      const wed = new Date(2025, 8, 17, 5, 0); // local SLC
      const frWed = computeFrameAccurate(wed, 40.7608, -111.8910, 'America/Denver');
      if(frWed.dayRulerKey !== 'mars') throw new Error('Before sunrise Wednesday â†’ day ruler Mars');

      out.textContent='PASS: hash + day-ruler pre-sunrise';
    } catch(e){ out.textContent='FAIL: '+e.message; }
  }
  </script>
</body>
</html>
