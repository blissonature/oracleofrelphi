function computeFrameAccurate(now, lat, lon, timeZone){
  // Build sunrise→next sunrise frame that contains `now` in target tz
  const { y, m, d, hh, mm } = toLocalPartsInTZ(now, timeZone);
  const todayLocalNoon = fromLocalPartsInTZ(y, m-1, d, 12, 0, 0, timeZone);

  // Sun times anchored to three consecutive local noons
  const yNoon = new Date(todayLocalNoon.getTime() - 86400000);
  const tNoon = new Date(todayLocalNoon.getTime() + 86400000);

  // Get both sunrise AND sunset for “yesterday” and “today”
  const yTimes = computeSunTimesLocal(yNoon,         lat, lon, timeZone); // sr0/ss0
  const tTimes = computeSunTimesLocal(todayLocalNoon,lat, lon, timeZone); // sr1/ss1
  if (yTimes.polar || tTimes.polar) {
    return {
      start: todayLocalNoon,
      end: new Date(todayLocalNoon.getTime()+86400000),
      sunrise: todayLocalNoon,
      sunset: todayLocalNoon,
      nextSunrise: new Date(todayLocalNoon.getTime()+86400000),
      dayRulerKey: DAY_RULERS[fromLocalPartsInTZ(y,m-1,d,0,0,0,timeZone).getDay()],
      polar: true
    };
  }

  const sr0 = yTimes.sunriseLocal, ss0 = yTimes.sunsetLocal;
  const sr1 = tTimes.sunriseLocal, ss1 = tTimes.sunsetLocal;
  const sr2 = computeSunTimesLocal(tNoon, lat, lon, timeZone).sunriseLocal;

  const nowLocal = fromLocalPartsInTZ(y, m-1, d, hh, mm, 0, timeZone);

  // Correct selection:
  // after today's sunrise: [sr1 .. sr2] with sunset = ss1
  // before today's sunrise: [sr0 .. sr1] with sunset = ss0  ← this was the missing piece
  let frameStart, frameEnd, frameSunset;
  if (nowLocal >= sr1) {
    frameStart = sr1; frameEnd = sr2; frameSunset = ss1;
  } else {
    frameStart = sr0; frameEnd = sr1; frameSunset = ss0;
  }

  const dayRulerKey = DAY_RULERS[ frameStart.getDay() ];
  return {
    start: frameStart,
    end: frameEnd,
    sunrise: sr1,
    sunset: frameSunset,
    nextSunrise: frameEnd,
    dayRulerKey,
    polar: false
  };
}
