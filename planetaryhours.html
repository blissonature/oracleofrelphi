<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Planetary Hours</title>
<style>
  :root { --fg:#111; --muted:#666; --line:#e6e6e6; --pill:#f5f5f5; --accent:#111; --good:#0a7; --bad:#b00; }
  html,body { margin:0; padding:0; color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#fff; }
  .wrap { max-width:1000px; margin: 24px auto 96px; padding: 0 16px; }
  h1 { font-size: 24px; margin: 0 0 8px; }
  .muted { color: var(--muted); }
  .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .col { display:flex; flex-direction:column; gap:6px; }
  .card { border:1px solid var(--line); border-radius:16px; padding:16px; background:#fff; }
  .pill { background: var(--pill); border:1px solid var(--line); border-radius:999px; padding:4px 10px; display:inline-flex; gap:6px; align-items:center; }
  .grid { display:grid; gap:12px; }
  .g2 { grid-template-columns: 1fr 1fr; }
  .g3 { grid-template-columns: repeat(3,1fr); }
  .bar { height:10px; background:#eee; border-radius:999px; overflow:hidden; }
  .bar > div { height:100%; width:0%; background: var(--accent); transition: width .4s ease; }
  .ticker { font-size: 14px; }
  .big { font-size: 32px; font-weight: 800; letter-spacing: .2px; display:flex; align-items:center; gap:.35em; }
  .mid { font-size: 18px; font-weight: 700; display:flex; align-items:center; gap:.4em; }
  .sym { font-size: 1.05em; }
  button, input, select { padding:7px 9px; border:1px solid var(--line); border-radius:10px; background:#fff; }
  button { cursor:pointer; }
  label { font-size:12px; color:#444; display:flex; gap:6px; align-items:center; }
  .hrline { height:1px; background:var(--line); margin:12px 0; }
  table { border-collapse: collapse; width:100%; }
  th, td { border-bottom:1px solid var(--line); padding:8px 6px; text-align:left; vertical-align:top; }
  th { font-size:12px; text-transform: uppercase; letter-spacing:.04em; color:#444; }
  .now { background: #fafafa; border-left: 3px solid #000; }
  .tiny { font-size:12px; color: var(--muted); }
  .delta.pos { color: var(--good); }
  .delta.neg { color: var(--bad); }
  .stack { display:grid; gap:6px; }
  .center { text-align:center; }
  .hero { display:grid; grid-template-columns: 1fr 1.2fr 1fr; align-items:center; gap:12px; }
  .hero .slot { min-height: 76px; }
  .bridge { font-weight: 600; }
  .chip { display:inline-flex; align-items:center; gap:.4em; padding:.25rem .6rem; border:1px solid var(--line); border-radius:999px; }
  .legend { display:flex; gap:8px; flex-wrap:wrap; }
  .anim-ruler { position: relative; height: 8px; background:#eee; border-radius:999px; overflow:hidden; }
  .anim-ruler > div { position:absolute; left:0; top:0; bottom:0; width:100%; transform: translateX(-100%); background:#000; animation: sweep linear forwards; }
  @keyframes sweep { from { transform: translateX(-100%); } to { transform: translateX(0%); } }
  .note { background:#fffef7; border:1px solid #f0e6b3; padding:8px 10px; border-radius:10px; }
  .warn { background:#fff5f5; border:1px solid #f3c2c2; padding:8px 10px; border-radius:10px; color:#7b1a1a; }
</style>
<!-- SunCalc for sunrise/sunset -->
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
<!-- Luxon for robust timezone handling -->
<script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
</head>
<body>
<div class="wrap">

  <div class="row" style="justify-content:space-between;">
    <div>
      <h1>Planetary Hours</h1>
      <div class="ticker mono" id="clock">—</div>
      <div class="tiny" id="statusLine">—</div>
    </div>
    <div class="legend tiny">
      <span class="chip"><span class="sym">♄</span> Saturn</span>
      <span class="chip"><span class="sym">♃</span> Jupiter</span>
      <span class="chip"><span class="sym">♂</span> Mars</span>
      <span class="chip"><span class="sym">☉</span> Sun</span>
      <span class="chip"><span class="sym">♀</span> Venus</span>
      <span class="chip"><span class="sym">☿</span> Mercury</span>
      <span class="chip"><span class="sym">☾</span> Moon</span>
    </div>
  </div>

  <!-- Controls -->
  <div class="card" style="margin-top:12px;">
    <div class="grid g2">
      <div class="col">
        <div class="tiny">Location</div>
        <div class="row">
          <button id="geoBtn" title="Browser geolocation">Use my location</button>
          <button id="utcBtn" title="UTC mode (0,0)">UTC (0°, 0°)</button>
        </div>
        <div class="row" style="margin-top:6px;">
          <label>Search place
            <input id="addr" placeholder="Address, landmark, city…" size="32" />
          </label>
          <button id="searchBtn">Find</button>
        </div>
        <div class="row" style="margin-top:6px;">
          <label>Lat <input id="lat" size="8" placeholder="40.7608"></label>
          <label>Lon <input id="lon" size="8" placeholder="-111.8910"></label>
          <button id="setLL">Set</button>
        </div>
        <div class="tiny mono" id="locEcho">—</div>
        <div class="warn tiny" id="geoWarn" style="display:none; margin-top:6px;">
          Geolocation needs HTTPS (or localhost). If it fails, use search or lat/lon.
        </div>
      </div>

      <div class="col">
        <div class="tiny">Time & Timezone</div>
        <div class="row">
          <label>Timezone
            <select id="tzMode">
              <option value="auto">Auto (system)</option>
              <option value="utc">UTC</option>
              <option value="custom">Custom IANA…</option>
            </select>
          </label>
          <input id="tzCustom" placeholder="e.g., America/Denver" style="display:none" />
        </div>
        <div class="row" style="margin-top:6px;">
          <label>Date <input type="date" id="datePick"></label>
          <label>Time <input type="time" id="timePick"></label>
          <button id="useNow">Use now</button>
          <button id="applyDT">Apply</button>
        </div>
        <div class="tiny" id="dtEcho">—</div>
      </div>
    </div>
  </div>

  <!-- Hero rulers -->
  <div class="card" style="margin-top:12px;">
    <div class="hero">
      <div class="slot center">
        <div class="tiny">Next ruler</div>
        <div class="mid" id="nextRuler">—</div>
      </div>
      <div class="slot">
        <div class="tiny">Current hour</div>
        <div class="big" id="currentRuler">—</div>
        <div class="row">
          <span class="pill mono" id="hrRange">—</span>
          <span class="pill mono" id="countdown">—</span>
          <span class="pill" id="brightDark">—</span>
        </div>
      </div>
      <div class="slot center">
        <div class="tiny">Previous ruler</div>
        <div class="mid" id="prevRuler">—</div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <div class="tiny">Progress</div>
      <div class="bar"><div id="progress"></div></div>
      <div class="anim-ruler" style="margin-top:6px;"><div id="sweep"></div></div>
    </div>

    <div class="hrline"></div>

    <div class="grid g3">
      <div class="stack">
        <div class="tiny">Day ruler</div>
        <div id="dayInfo">—</div>
      </div>
      <div class="stack">
        <div class="tiny">Hour ruler</div>
        <div id="hourInfo">—</div>
      </div>
      <div class="stack">
        <div class="tiny">Multiplier</div>
        <div id="multInfo" class="mid">—</div>
      </div>
    </div>

    <div class="hrline"></div>

    <div class="grid g3">
      <div class="stack">
        <div class="tiny">Sunrise / Sunset</div>
        <div id="sunInfo" class="mono">—</div>
      </div>
      <div class="stack">
        <div class="tiny">Bridge hour (last dark hour)</div>
        <div id="bridgeInfo">—</div>
      </div>
      <div class="stack">
        <div class="tiny">Δ at daybreak</div>
        <div id="bridgeDelta" class="mid">—</div>
      </div>
    </div>
  </div>

  <!-- Day planner table -->
  <div class="card" style="margin-top:12px;">
    <div class="row" style="justify-content:space-between;">
      <div class="mid">Today’s Planetary Hours</div>
      <div class="tiny" id="weekdayEcho">—</div>
    </div>
    <div class="hrline"></div>
    <table id="hoursTable">
      <thead>
        <tr>
          <th>#</th>
          <th>Phase</th>
          <th>Start</th>
          <th>End</th>
          <th>Ruler</th>
          <th>Focus</th>
          <th>Multiplier</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="note tiny" style="margin-top:10px;">
      Multiplier = x(day weight × hour weight), weights are sidereal orbital periods (years). Phase labels: Bright (sunrise→sunset), Dark (sunset→next sunrise).
    </div>
  </div>

</div>

<script>
(function(){
  const DateTime = luxon.DateTime;

  // ——— Data
  const ORDER = ["Saturn","Jupiter","Mars","Sun","Venus","Mercury","Moon"];
  const SYMBOL = { Saturn:"♄", Jupiter:"♃", Mars:"♂", Sun:"☉", Venus:"♀", Mercury:"☿", Moon:"☾" };
  const WEEKDAY = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
  const DAY_RULER = { 0:"Sun", 1:"Moon", 2:"Mars", 3:"Mercury", 4:"Jupiter", 5:"Venus", 6:"Saturn" };
  const WEIGHT = { Saturn:29.5, Jupiter:11.9, Mars:1.88, Sun:1.0, Venus:0.62, Mercury:0.24, Moon:0.075 };
  const ESSENCE = {
    Sun:"Vitality, visibility, leadership",
    Moon:"Care, memory, intuition",
    Mars:"Action, courage, cutting",
    Mercury:"Speech, learning, commerce",
    Jupiter:"Meaning, growth, blessing",
    Venus:"Harmony, attraction, aesthetics",
    Saturn:"Structure, limits, duty"
  };
  const FOCUS_BRIGHT = {
    Sun:"Lead, shine, self-expression",
    Moon:"Emotional clarity with warmth",
    Mars:"Bold action, decisive push",
    Mercury:"Communication, learning",
    Jupiter:"Abundance, teaching, planning",
    Venus:"Beauty, art, connection",
    Saturn:"Structure, discipline, edits"
  };
  const FOCUS_DARK = {
    Sun:"Restore vitality, inner radiance",
    Moon:"Subconscious healing, deep care",
    Mars:"Inner resolve, martial calm",
    Mercury:"Dream journaling, reflection",
    Jupiter:"Satisfying rest, quiet faith",
    Venus:"Soothing affection, reconciliation",
    Saturn:"Grounding, stillness, order"
  };

  // ——— Utils
  const $ = s => document.querySelector(s);
  const fmtTime = (d, tz) => DateTime.fromJSDate(d).setZone(tz).toFormat("h:mm a");
  const fmtDate = (d, tz) => DateTime.fromJSDate(d).setZone(tz).toFormat("MMM d, yyyy");
  const pad2 = n => String(n).padStart(2,'0');
  const clamp = (x,a,b) => Math.max(a, Math.min(b,x));
  const chaldean = (start, len)=> {
    const s = ORDER.indexOf(start);
    return Array.from({length: len}, (_,i)=> ORDER[(s+i)%7]);
  };

  // ——— State
  let state = {
    lat: 40.7608, lon: -111.8910,
    tzMode: 'auto', tzCustom: '',
    when: null,                 // JS Date in real time
    anchorTZ: Intl.DateTimeFormat().resolvedOptions().timeZone,
    schedule: [],
    sunrise:null, sunset:null, nextSunrise:null,
    weekdayName:'', dayRuler:'', bridgeHour:null, bridgeDelta:null
  };

  // Build schedule for the civil day in selected tz
  function buildSchedule(anchorJSDate, tzMode, lat, lon){
    const zone = (tzMode==='auto') ? Intl.DateTimeFormat().resolvedOptions().timeZone
               : (tzMode==='utc' ? 'UTC' : tzMode);
    // Civil date in zone
    const anchor = DateTime.fromJSDate(anchorJSDate).setZone(zone);
    const civil = anchor.startOf('day'); // local midnight in chosen zone

    // Sun times (SunCalc expects JS Date in local/UTC; it uses epoch internally)
    const todayMidJS = civil.toJSDate();
    const timesToday = SunCalc.getTimes(todayMidJS, lat, lon);
    const sunrise = timesToday.sunrise;
    const sunset  = timesToday.sunset;

    const tomorrowMidJS = civil.plus({days:1}).toJSDate();
    const timesTomorrow = SunCalc.getTimes(tomorrowMidJS, lat, lon);
    const nextSunrise = timesTomorrow.sunrise;

    if(!sunrise || !sunset || !nextSunrise) throw new Error("Sun never rises/sets for this date/location.");

    const dayLen = sunset - sunrise;
    const nightLen = nextSunrise - sunset;
    const dayHour = dayLen / 12;
    const nightHour = nightLen / 12;

    const weekdayName = WEEKDAY[ DateTime.fromJSDate(sunrise).setZone(zone).weekday % 7 ];
    const weekdayIdx = DateTime.fromJSDate(sunrise).setZone(zone).weekday % 7; // 0 Sun … 6 Sat (we’ll remap)
    const jsSunrise = DateTime.fromJSDate(sunrise).setZone(zone);
    const dayRuler = DAY_RULER[jsSunrise.toJSDate().getDay()]; // day starts at sunrise by weekday

    // Sequences
    const daySeq = chaldean(dayRuler, 12);
    const nightSeq = chaldean(daySeq[12 % 7], 12);

    const out = [];
    for(let i=0;i<12;i++){
      const start = new Date(sunrise.getTime() + i*dayHour);
      const end   = new Date(sunrise.getTime() + (i+1)*dayHour);
      out.push({ idx:i+1, phase:"Bright", planet: daySeq[i], start, end });
    }
    for(let i=0;i<12;i++){
      const start = new Date(sunset.getTime() + i*nightHour);
      const end   = new Date(sunset.getTime() + (i+1)*nightHour);
      out.push({ idx:13+i, phase:"Dark", planet: nightSeq[i], start, end });
    }

    // Bridge hour (last dark hour) and Δ to next day first hour
    const bridge = out[23];
    const nextDayIdx = (DateTime.fromJSDate(sunrise).toJSDate().getDay()+1)%7;
    const nextDayRuler = DAY_RULER[nextDayIdx];
    const nextSeqFirst = chaldean(nextDayRuler,1)[0];
    const bridgeDelta = (WEIGHT[nextDayRuler] * WEIGHT[nextSeqFirst]) - (WEIGHT[dayRuler] * WEIGHT[bridge.planet]);

    return {out, sunrise, sunset, nextSunrise, weekdayName, dayRuler, bridgeHour:bridge, bridgeDelta, zone};
  }

  function renderAll(){
    const tz = state.anchorTZ;
    const now = state.when || new Date();
    $("#clock").textContent = `${fmtDate(now, tz)} • ${DateTime.fromJSDate(now).setZone(tz).toFormat("h:mm a")}`;
    $("#statusLine").textContent = `Location ${state.lat.toFixed(4)}, ${state.lon.toFixed(4)} • TZ: ${tz}`;

    const sched = state.schedule;
    const msNow = now.getTime();
    const idx = sched.findIndex(h => msNow >= h.start.getTime() && msNow < h.end.getTime());
    const cur = (idx>=0)? sched[idx] : null;
    const prev = (idx>0)? sched[idx-1] : null;
    const next = (idx>=0 && idx<sched.length-1)? sched[idx+1] : null;

    $("#currentRuler").innerHTML = cur ? `${SYMBOL[cur.planet]} ${cur.planet}` : "—";
    $("#prevRuler").innerHTML = prev ? `${SYMBOL[prev.planet]} ${prev.planet}` : "—";
    $("#nextRuler").innerHTML = next ? `${SYMBOL[next.planet]} ${next.planet}` : "—";
    $("#hrRange").textContent = cur ? `${fmtTime(cur.start, tz)} – ${fmtTime(cur.end, tz)}` : "—";
    $("#brightDark").textContent = cur ? cur.phase : "—";

    if(cur){
      const remain = cur.end - msNow;
      const dur = cur.end - cur.start;
      const mm = Math.floor((remain/1000/60)%60);
      const hh = Math.floor((remain/1000/3600));
      $("#countdown").textContent = `Next in ${hh? hh+":" : ""}${String(mm).padStart(2,'0')}`;
      $("#progress").style.width = `${clamp(100*(1 - remain/dur),0,100)}%`;

      const sweep = $("#sweep");
      sweep.style.animationDuration = `${dur/1000}s`;
      const elapsed = (msNow - cur.start)/dur;
      sweep.style.animationDelay = `${-elapsed * (dur/1000)}s`;
    } else {
      $("#countdown").textContent = "—";
      $("#progress").style.width = "0%";
    }

    // Day + Hour info + Mult
    $("#weekdayEcho").textContent = `${state.weekdayName} ruled by ${state.dayRuler}`;
    $("#sunInfo").textContent = `Sunrise ${fmtTime(state.sunrise, tz)} • Sunset ${fmtTime(state.sunset, tz)} • Next sunrise ${fmtTime(state.nextSunrise, tz)}`;

    const dayEss = ESSENCE[state.dayRuler];
    $("#dayInfo").innerHTML = `<span class="mid"><span class="sym">${SYMBOL[state.dayRuler]}</span> ${state.dayRuler}</span>
      <div class="tiny">Weight: <span class="mono">x${WEIGHT[state.dayRuler]}</span> • ${dayEss}</div>`;

    if(cur){
      const focus = (cur.phase==="Bright"? FOCUS_BRIGHT : FOCUS_DARK)[cur.planet];
      const wH = WEIGHT[cur.planet];
      $("#hourInfo").innerHTML = `<span class="mid"><span class="sym">${SYMBOL[cur.planet]}</span> ${cur.planet} <span class="tiny">(${cur.phase})</span></span>
        <div class="tiny">Weight: <span class="mono">x${wH}</span> • ${focus}</div>`;
      $("#multInfo").innerHTML = `<span class="mono">x${(WEIGHT[state.dayRuler]*wH).toFixed(3)}</span>`;
    } else {
      $("#hourInfo").textContent = "—";
      $("#multInfo").textContent = "—";
    }

    // Bridge
    const b = state.bridgeHour;
    const nextDayRuler = DAY_RULER[(state.sunrise.getDay()+1)%7];
    const nextFirst = chaldean(nextDayRuler,1)[0];
    $("#bridgeInfo").innerHTML = `
      <span class="bridge">${fmtTime(b.start, tz)}–${fmtTime(b.end, tz)}</span> •
      Last dark ruler: <strong>${SYMBOL[b.planet]} ${b.planet}</strong> → Next day first ruler: <strong>${SYMBOL[nextFirst]} ${nextFirst}</strong>`;
    const d = state.bridgeDelta; const sign = (d>=0)?'pos':'neg';
    $("#bridgeDelta").innerHTML = `<span class="delta ${sign}">${d>=0?'+':''}${d.toFixed(3)}</span>`;

    // Table
    const tbody = $("#hoursTable tbody"); tbody.innerHTML = "";
    sched.forEach(h=>{
      const tr = document.createElement('tr');
      if(cur && h.idx===cur.idx) tr.classList.add('now');
      const focus = (h.phase==="Bright"? FOCUS_BRIGHT : FOCUS_DARK)[h.planet];
      const mult = WEIGHT[state.dayRuler]*WEIGHT[h.planet];
      tr.innerHTML = `
        <td class="mono">${h.idx}</td>
        <td>${h.phase}</td>
        <td class="mono">${fmtTime(h.start, tz)}</td>
        <td class="mono">${fmtTime(h.end, tz)}</td>
        <td><span class="sym">${SYMBOL[h.planet]}</span> ${h.planet}</td>
        <td class="tiny" style="max-width:420px">${focus}</td>
        <td class="mono">x${mult.toFixed(3)}</td>`;
      tbody.appendChild(tr);
    });
  }

  function recalc(){
    state.anchorTZ = (state.tzMode==='auto') ? Intl.DateTimeFormat().resolvedOptions().timeZone
                  : (state.tzMode==='utc' ? 'UTC' : state.tzCustom || Intl.DateTimeFormat().resolvedOptions().timeZone);
    const when = state.when || new Date();
    try{
      const built = buildSchedule(when, (state.tzMode==='custom'? state.tzCustom : state.tzMode), state.lat, state.lon);
      state.schedule = built.out;
      state.sunrise = built.sunrise;
      state.sunset = built.sunset;
      state.nextSunrise = built.nextSunrise;
      state.weekdayName = built.weekdayName;
      state.dayRuler = built.dayRuler;
      state.bridgeHour = built.bridgeHour;
      state.bridgeDelta = built.bridgeDelta;
      renderAll();
    }catch(e){
      alert("Schedule error: " + e.message);
    }
  }

  // ——— Controls
  const geoBtn = $("#geoBtn"), utcBtn=$("#utcBtn"), addr=$("#addr"), searchBtn=$("#searchBtn");
  const latIn=$("#lat"), lonIn=$("#lon"), setLL=$("#setLL");
  const tzMode=$("#tzMode"), tzCustom=$("#tzCustom");
  const datePick=$("#datePick"), timePick=$("#timePick"), useNow=$("#useNow"), applyDT=$("#applyDT");
  const locEcho=$("#locEcho"), dtEcho=$("#dtEcho"), geoWarn=$("#geoWarn");

  function echoLoc(){ locEcho.textContent = `${state.lat.toFixed(4)}, ${state.lon.toFixed(4)} (${state.anchorTZ})`; }
  function echoDT(){
    const tz = state.anchorTZ;
    dtEcho.textContent = state.when
      ? `Custom datetime: ${DateTime.fromJSDate(state.when).setZone(tz).toFormat("MMM d, yyyy • h:mm a")}`
      : `Using system clock`;
  }

  geoBtn.onclick = ()=>{
    const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';
    geoWarn.style.display = isSecure ? 'none' : 'block';
    if(!navigator.geolocation){ alert("Geolocation not supported."); return; }
    navigator.geolocation.getCurrentPosition(
      pos=>{
        state.lat = pos.coords.latitude; state.lon = pos.coords.longitude;
        echoLoc(); recalc();
      },
      err=> alert("Location error: " + err.message),
      { enableHighAccuracy:true, timeout:10000, maximumAge:60000 }
    );
  };

  utcBtn.onclick = ()=>{
    state.lat = 0; state.lon = 0;
    state.tzMode = 'utc'; tzMode.value = 'utc';
    echoLoc(); recalc();
  };

  // Address search via geocode.maps.co (Nominatim wrapper with CORS)
  searchBtn.onclick = async ()=>{
    const q = addr.value.trim();
    if(!q){ alert("Enter a place name or address."); return; }
    try{
      const url = `https://geocode.maps.co/search?q=${encodeURIComponent(q)}&limit=1`;
      const res = await fetch(url, {headers:{'Accept':'application/json'}});
      if(!res.ok) throw new Error(res.status + " " + res.statusText);
      const js = await res.json();
      if(!js.length){ alert("No results."); return; }
      const best = js[0];
      state.lat = parseFloat(best.lat);
      state.lon = parseFloat(best.lon);
      echoLoc(); recalc();
    }catch(e){
      alert("Search failed: " + e.message);
    }
  };

  setLL.onclick = ()=>{
    const la = parseFloat(latIn.value), lo = parseFloat(lonIn.value);
    if(Number.isNaN(la) || Number.isNaN(lo)){ alert("Enter valid lat/lon."); return; }
    state.lat = la; state.lon = lo; echoLoc(); recalc();
  };

  tzMode.onchange = ()=>{
    state.tzMode = tzMode.value;
    tzCustom.style.display = (state.tzMode==='custom') ? 'inline-block' : 'none';
    if(state.tzMode!=='custom'){ state.tzCustom=''; }
    recalc();
  };
  tzCustom.onchange = ()=>{
    try{
      // Validate zone with Luxon
      const test = DateTime.now().setZone(tzCustom.value);
      if(!test.isValid) throw new Error("Invalid IANA timezone");
      state.tzCustom = tzCustom.value;
      recalc();
    }catch(e){ alert("Invalid IANA timezone."); }
  };

  useNow.onclick = ()=>{ state.when = null; datePick.value=""; timePick.value=""; echoDT(); recalc(); };
  applyDT.onclick = ()=>{
    const z = (state.tzMode==='auto') ? Intl.DateTimeFormat().resolvedOptions().timeZone
             : (state.tzMode==='utc' ? 'UTC' : (state.tzCustom || Intl.DateTimeFormat().resolvedOptions().timeZone));
    const today = DateTime.now().setZone(z);
    const dval = datePick.value ? DateTime.fromISO(datePick.value, {zone:z}) : today;
    const tval = timePick.value || "00:00";
    const [hh,mm] = tval.split(":").map(x=>parseInt(x,10));
    const custom = dval.set({hour:hh, minute:mm, second:0, millisecond:0});
    if(!custom.isValid){ alert("Invalid date/time."); return; }
    state.when = custom.toJSDate();
    echoDT(); recalc();
  };

  function tick(){
    if(!state.when){ renderAll(); }
    requestAnimationFrame(tick);
  }

  (function init(){
    state.tzMode = 'auto';
    state.when = null;
    echoLoc(); echoDT();
    recalc(); tick();
  })();

})();
</script>
</body>
</html>
