<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Planetary Hours</title>
<link rel="preconnect" href="https://unpkg.com">
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
<style>
  :root{
    --bg:#fff; --ink:#111; --sub:#666; --muted:#999; --line:#e9e9e9;
    --pill:#f4f4f5; --pill-ink:#111;
    --bar:#eee; --bar-fill:#111; --accent:#111;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  body{margin:0;background:var(--bg);color:var(--ink);}
  .wrap{max-width:1080px;margin:0 auto;padding:18px;}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap;margin-bottom:10px}
  h1{font-size:22px;margin:0;font-weight:750}
  .clock{font-variant-numeric:tabular-nums;color:var(--sub)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .card{border:1px solid var(--line);border-radius:14px;padding:14px;margin:14px 0}
  label{font-size:13px;color:var(--sub)}
  input,select,button{padding:8px 10px;border-radius:10px;border:1px solid var(--line);background:#fff}
  button.primary{background:black;color:#fff;border-color:#000}
  .tiny{font-size:12px;color:var(--sub)}
  .mono{font-variant-numeric:tabular-nums; font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .pill{background:var(--pill);color:var(--pill-ink);border:1px solid var(--line);padding:8px 12px;border-radius:999px;display:inline-flex;gap:8px;align-items:center}
  .big{font-size:64px;font-weight:800;line-height:1.05;margin:6px 0}
  .subpill{padding:6px 10px;border-radius:999px;background:#f6f6f7;border:1px solid #e7e7ea}
  .hero{position:relative}
  .ticker{height:10px;background:var(--bar);border-radius:999px;overflow:hidden;position:relative}
  .ticker > div{height:100%;background:var(--bar-fill);width:0%}
  .ticker-marks{position:absolute;left:0;right:0;top:-22px;display:flex;justify-content:space-between;color:var(--sub)}
  .edgePills{display:flex;justify-content:space-between;margin:8px 0 2px 0}
  .edgePills .pill{min-width:200px;justify-content:space-between}
  .centerline{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .divider{height:1px;background:var(--line);margin:12px 0}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid var(--line);vertical-align:top}
  th{position:sticky;top:0;background:#fff}
  tr.now{background:#fff7ea}
  .bad{color:#a00}
  .good{color:#0a0}
  .grid{display:grid;gap:12px}
  @media(min-width:900px){ .grid2{grid-template-columns:1.1fr 1fr 0.8fr} }
  .planet{display:inline-flex;align-items:center;gap:8px}
  .kicker{font-size:18px;font-weight:700}
  .note{color:#555}
</style>
</head>
<body>
<div class="wrap">

  <!-- Header -->
  <header>
    <div class="row">
      <h1>Planetary Hours</h1>
    </div>
    <div class="row">
      <span class="clock mono" id="liveClock">—:—</span>
      <button id="copyLink">Copy link to this view</button>
    </div>
  </header>

  <!-- Location & Time controls -->
  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <button id="geoBtn">Use my location</button>
        <select id="tzSel">
          <option value="system">America/Denver (system)</option>
          <option value="UTC">UTC (0°, 0°)</option>
        </select>
        <label>Lat <input id="lat" size="10" class="mono" /></label>
        <label>Lon <input id="lon" size="10" class="mono" /></label>
        <button id="setLL">Set</button>
      </div>
      <div class="row">
        <label class="row" style="gap:6px;">
          Date
          <input id="dateSel" type="date">
        </label>
        <label class="row" style="gap:6px;">
          Time
          <input id="timeSel" type="time" step="60">
        </label>
        <button id="nowBtn">Use now</button>
        <button id="applyBtn">Apply</button>
      </div>
    </div>
    <div class="tiny mono" id="locEcho">—</div>
    <div class="tiny">Day runs from sunrise → next sunrise.</div>
  </div>

  <!-- HERO: current hour band -->
  <div class="card hero" id="heroCard">
    <div class="edgePills">
      <div class="pill mono" id="nextPill">Next: —</div>
      <div class="pill mono" id="prevPill">—</div>
    </div>

    <div class="ticker" id="ticker"><div></div></div>

    <div class="centerline" style="margin-top:10px">
      <div class="big"><span id="hourGlyph">◯</span> <span id="hourName">—</span></div>
      <div class="row">
        <div class="pill mono" id="range">—</div>
        <div class="pill mono" id="countdown">Next in —</div>
      </div>
    </div>

    <div class="divider"></div>

    <div class="grid grid2">
      <div>
        <div class="kicker">Day ruler</div>
        <div class="row" style="margin-top:8px"><span class="pill" id="dayPill">—</span></div>
        <div class="tiny note" id="dayFocus">—</div>
        <div class="tiny mono" id="sunTimes" style="margin-top:8px">—</div>
      </div>

      <div>
        <div class="kicker">Hour ruler</div>
        <div class="row" style="margin-top:8px;align-items:center;gap:8px;">
          <span class="pill" id="hourPill">—</span>
          <span class="subpill tiny mono" id="phaseBadge">—</span>
        </div>
        <div class="tiny note" id="hourFocus" style="margin-top:6px">—</div>

        <div class="row" style="margin-top:10px;gap:6px">
          <span class="subpill tiny mono" id="ordinalChip">—</span>
          <span class="subpill tiny mono" id="hourOfDayChip">—</span>
          <span class="subpill tiny mono" id="hoursRuledChip">—</span>
        </div>
      </div>

      <div>
        <div class="kicker">Multiplier</div>
        <div class="big mono" id="multBig" style="font-size:40px;margin-top:6px">x—</div>
        <div class="tiny note">Power = day orbit × hour orbit • Harmonic: <span id="harmonicNote">—</span></div>
      </div>
    </div>

    <div class="divider"></div>

    <div class="row tiny mono" id="bridgeInfo">—</div>
  </div>

  <!-- Day table -->
  <div class="card">
    <div class="kicker" style="margin-bottom:8px">Today’s Planetary Hours</div>
    <div class="tiny" id="weekdayBanner" style="margin-bottom:6px">—</div>
    <div style="overflow:auto">
      <table id="hoursTable">
        <thead>
          <tr>
            <th># / phase</th>
            <th>Start</th>
            <th>End</th>
            <th>Ruler</th>
            <th>Order</th>
            <th>Hour n/24</th>
            <th>Hours ruled (B/D/T)</th>
            <th>Multiplier</th>
            <th>Focus</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- 7×7 Focus Matrix -->
  <div class="card">
    <div class="kicker" style="margin-bottom:8px">7×7 Focus Matrix (Day × Hour)</div>
    <div class="tiny" style="margin-bottom:6px">Concise hour guidance by day ruler. (Bright/Dark tones applied in context.)</div>
    <div style="overflow:auto">
      <table id="matrix">
        <thead><tr id="mxHead"></tr></thead>
        <tbody id="mxBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Weekly bridge table -->
  <div class="card">
    <div class="kicker" style="margin-bottom:8px">Bridge Hours (last dark → first bright)</div>
    <div style="overflow:auto">
      <table id="bridges">
        <thead>
          <tr>
            <th>Day (last dark)</th>
            <th>Ruler ×</th>
            <th>Next day (first bright)</th>
            <th>Ruler ×</th>
            <th>Δ</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="tiny note" style="margin-top:6px">The Venus → Saturn transition is typically the largest jump.</div>
  </div>

  <!-- About / Help -->
  <details class="card">
    <summary class="kicker">About & Help</summary>
    <div class="tiny" style="margin-top:8px;line-height:1.6">
      <p><strong>Planetary day</strong> runs from <em>sunrise → next sunrise</em>. Before today’s sunrise, the day ruler is yesterday’s ruler.</p>
      <p><strong>Multipliers</strong> use sidereal orbits (years): Saturn 29.46, Jupiter 11.86, Mars 1.88, Sun 1.00, Venus 0.615, Mercury 0.241, Moon 0.0748. The hour’s power is day × hour.</p>
      <p><strong>Ordinals & Harmonics</strong>: Each planet rules up to four hours per day. The 1st, 2nd, 3rd, 4th occurrences correspond to Fundamental, Octave, Fifth, Double Octave. We display the ordinal chip and note the harmonic; the main multiplier remains day×hour (we don’t scale the number), while the harmonic chip explains the “feel.”</p>
      <p><strong>Bridge hour</strong> is the last dark hour before sunrise; we show its ruler and compare to the first bright hour after sunrise (Δ).</p>
      <p>Use the “Copy link to this view” button to deep-link your exact lat/lon, timezone, and time.</p>
    </div>
  </details>

</div>

<script>
(() => {
  // --------- Data
  const ORDER = ["Saturn","Jupiter","Mars","Sun","Venus","Mercury","Moon"];
  const DAY_RULER = {0:"Sun",1:"Moon",2:"Mars",3:"Mercury",4:"Jupiter",5:"Venus",6:"Saturn"};
  const WEEKDAY_NAME = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
  const GLYPH = {Sun:"☉", Moon:"☽", Mercury:"☿", Venus:"♀", Mars:"♂", Jupiter:"♃", Saturn:"♄"};
  const ORBITS = {Saturn:29.46, Jupiter:11.86, Mars:1.88, Sun:1.0, Venus:0.615, Mercury:0.241, Moon:0.0748};

  // Hour-focus (concise) and Day-focus (concise)
  const HOUR_FOCUS = {
    Sun:"Lead, shine, self-expression",
    Moon:"Dream incubation, subconscious healing",
    Mars:"Bold action, decisive push / Inner discipline, calm resolve",
    Mercury:"Communication, learning / Drafts, analysis, silent planning",
    Jupiter:"Abundance, teaching, wise growth / Satisfying rest, quiet faith",
    Venus:"Beauty, art, connection / Night comfort, reconciliation",
    Saturn:"Grounding, stillness, solitude / Structure, sober choices"
  };
  const DAY_FOCUS = {
    Sun:"Radiance, leadership, creative life-force",
    Moon:"Care, rhythm, memory, tides",
    Mars:"Action, courage, cutting",
    Mercury:"Thinking, trade, messages",
    Jupiter:"Growth, teaching, wisdom",
    Venus:"Harmony, affection, aesthetics",
    Saturn:"Discipline, boundaries, time"
  };

  // Matrix blurbs: (hour on day) short line
  const MATRIX_BLURB = (hour, day) => {
    // Tailored blend: hour-first phrasing + day climate
    const base = {
      Sun:"Express and steer",
      Moon:"Feel and integrate",
      Mars:"Cut through / act",
      Mercury:"Think and connect",
      Jupiter:"Teach and grow",
      Venus:"Soften and harmonize",
      Saturn:"Stabilize and structure"
    }[hour];
    const climate = {
      Sun:" under solar spotlight.",
      Moon:" in lunar rhythm.",
      Mars:" within martial pressure.",
      Mercury:" inside mercurial traffic.",
      Jupiter:" in jovial expansion.",
      Venus:" amid venusian ease.",
      Saturn:" with saturnine gravity."
    }[day];
    return base+climate;
  };

  // Harmonics by ordinal
  const ORDINAL_LABEL = ["—","1st","2nd","3rd","4th"];
  const HARMONIC = {1:"Fundamental",2:"Octave",3:"Fifth",4:"Double Octave"};

  // --------- Helpers
  const $ = sel => document.querySelector(sel);
  const fmt = (d) => d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  const pad2 = n => String(n).padStart(2,'0');
  const startOfLocalDay = d => new Date(d.getFullYear(), d.getMonth(), d.getDate());
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

  function chaldeanSequence(startPlanet, length){
    const start = ORDER.indexOf(startPlanet);
    const seq = [];
    for(let i=0;i<length;i++) seq.push(ORDER[(start + i) % ORDER.length]);
    return seq;
  }

  // Pick sunrise anchor (yesterday if pre-sunrise)
  function pickPlanetaryDayAnchor(lat, lon, now=new Date()){
    const today0 = startOfLocalDay(now);
    const tToday = SunCalc.getTimes(today0, lat, lon);
    if (!tToday.sunrise || !tToday.sunset) return {anchor:today0, times:tToday};
    if (now < tToday.sunrise) {
      const y0 = new Date(today0); y0.setDate(y0.getDate()-1);
      return {anchor:y0, times:SunCalc.getTimes(y0, lat, lon)};
    }
    return {anchor:today0, times:tToday};
  }

  function buildSchedule(anchor0, lat, lon){
    const times = SunCalc.getTimes(anchor0, lat, lon);
    const {sunrise, sunset} = times;
    const nextSunrise = SunCalc.getTimes(new Date(anchor0.getFullYear(),anchor0.getMonth(),anchor0.getDate()+1), lat, lon).sunrise;

    if(!sunrise || !sunset || !nextSunrise) throw new Error("Sun never rises/sets for this date/location.");

    const dayLen = sunset - sunrise, nightLen = nextSunrise - sunset;
    const dayHour = dayLen/12, nightHour = nightLen/12;

    const weekday = anchor0.getDay(); // day ruler from anchor’s weekday
    const dayRuler = DAY_RULER[weekday];

    const daySeq = chaldeanSequence(dayRuler, 12);
    const nightSeq = chaldeanSequence(daySeq[12 % 7], 12);

    const list = [];
    for(let i=0;i<12;i++){
      const start = new Date(sunrise.getTime()+i*dayHour);
      const end   = new Date(sunrise.getTime()+(i+1)*dayHour);
      list.push({idx:i+1, start, end, planet:daySeq[i], phase:"Bright"});
    }
    for(let i=0;i<12;i++){
      const start = new Date(sunset.getTime()+i*nightHour);
      const end   = new Date(sunset.getTime()+(i+1)*nightHour);
      list.push({idx:13+i, start, end, planet:nightSeq[i], phase:"Dark"});
    }

    return {list, sunrise, sunset, nextSunrise, dayRuler, weekdayName: WEEKDAY_NAME[weekday]};
  }

  function hoursRuledStats(list){
    const stats = {};
    ORDER.forEach(p=> stats[p]={B:0,D:0,T:0, ords:[]});
    list.forEach(h=>{
      const s=stats[h.planet];
      if(h.phase==="Bright") s.B++; else s.D++;
      s.T++; s.ords.push(h.idx);
    });
    return stats;
  }

  function ordinalsFor(list){
    // map hour idx => ordinal count for that planet seen so far
    const seen = {}; const out={};
    list.forEach(h=>{
      const p=h.planet;
      seen[p]=(seen[p]||0)+1;
      out[h.idx]=Math.min(seen[p],4);
    });
    return out;
  }

  function multiplier(dayPlanet, hourPlanet){
    return ORBITS[dayPlanet]*ORBITS[hourPlanet];
  }

  // --------- State
  let state = {
    lat: 40.7608,
    lon: -111.8910,
    tzMode: "system", // or "UTC"
    now: new Date(),
    manual: null, // Date if manual Apply used
    schedule: [],
    sunrise:null, sunset:null, nextSunrise:null,
    dayRuler:null, weekdayName:null,
    ordMap:{}, stats:{}
  };

  // --------- UI binds
  const liveClock = $("#liveClock");
  const copyLinkBtn = $("#copyLink");

  const geoBtn = $("#geoBtn");
  const tzSel = $("#tzSel");
  const latIn = $("#lat");
  const lonIn = $("#lon");
  const setLL = $("#setLL");
  const dateSel = $("#dateSel");
  const timeSel = $("#timeSel");
  const nowBtn = $("#nowBtn");
  const applyBtn = $("#applyBtn");
  const locEcho = $("#locEcho");

  const nextPill = $("#nextPill");
  const prevPill = $("#prevPill");
  const ticker = $("#ticker"); const tickerFill = $("#ticker > div");
  const hourGlyph = $("#hourGlyph");
  const hourName = $("#hourName");
  const rangeEl = $("#range");
  const countdownEl = $("#countdown");

  const dayPill = $("#dayPill");
  const dayFocus = $("#dayFocus");
  const sunTimes = $("#sunTimes");

  const hourPill = $("#hourPill");
  const phaseBadge = $("#phaseBadge");
  const hourFocus = $("#hourFocus");
  const multBig = $("#multBig");
  const harmonicNote = $("#harmonicNote");

  const ordinalChip = $("#ordinalChip");
  const hourOfDayChip = $("#hourOfDayChip");
  const hoursRuledChip = $("#hoursRuledChip");

  const bridgeInfo = $("#bridgeInfo");

  const hoursTableBody = $("#hoursTable tbody");
  const weekdayBanner = $("#weekdayBanner");

  // Matrix
  const mxHead = $("#mxHead");
  const mxBody = $("#mxBody");

  // Bridges weekly
  const bridgesBody = $("#bridges tbody");

  function tzName(){
    if (state.tzMode==="UTC") return "UTC";
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  }

  function getNow(){
    return state.manual ? new Date(state.manual) : new Date();
  }

  function updateClock(){
    const d=getNow();
    liveClock.textContent = d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  }

  function rebuild(forcedNow=null){
    if(forcedNow) state.manual = new Date(forcedNow);
    state.now = getNow();
    const tz = tzName();

    // echo
    locEcho.textContent = `${state.lat.toFixed(4)}, ${state.lon.toFixed(4)} (${tz})`;

    // anchor & schedule
    const {anchor, times} = pickPlanetaryDayAnchor(state.lat, state.lon, state.now);
    const built = buildSchedule(anchor, state.lat, state.lon);
    state.schedule = built.list;
    state.sunrise = built.sunrise; state.sunset = built.sunset; state.nextSunrise = built.nextSunrise;
    state.dayRuler = built.dayRuler; state.weekdayName = built.weekdayName;
    state.ordMap = ordinalsFor(state.schedule);
    state.stats = hoursRuledStats(state.schedule);

    paintHero();
    paintTable();
    paintMatrix();
    paintWeeklyBridges();
  }

  function planetGlyphName(p){ return `${GLYPH[p]} ${p}`; }

  function hourAt(ts){
    return state.schedule.find(h=> ts>=h.start.getTime() && ts<h.end.getTime());
  }

  function paintHero(){
    const now = getNow().getTime();
    const cur = hourAt(now) || state.schedule[0];
    const idx = cur.idx;
    const i = state.schedule.findIndex(h=>h.idx===idx);

    // next/prev pills aligned with ticker flow (Next left, Previous right)
    const prev = state.schedule[(i-1+24)%24];
    const next = state.schedule[(i+1)%24];
    nextPill.innerHTML = `Next: <span class="mono">${GLYPH[next.planet]} ${next.planet}</span> <span class="tiny mono">starts ${fmt(next.start)}</span>`;
    prevPill.innerHTML = `<span class="mono">${GLYPH[prev.planet]} ${prev.planet}</span> <span class="tiny mono">ended ${fmt(prev.end)}</span>`;

    // ticker
    const dur = cur.end - cur.start;
    const remain = cur.end.getTime() - now;
    const prog = clamp(100*(1-remain/dur),0,100);
    tickerFill.style.width = `${prog}%`;

    hourGlyph.textContent = GLYPH[cur.planet];
    hourName.textContent = cur.planet;
    rangeEl.textContent = `${fmt(cur.start)} – ${fmt(cur.end)}`;
    const mm = Math.floor(remain/60000), ss = Math.floor((remain%60000)/1000);
    countdownEl.textContent = `Next in ${pad2(mm)}:${pad2(ss)}`;

    // day block
    dayPill.textContent = planetGlyphName(state.dayRuler);
    dayFocus.textContent = DAY_FOCUS[state.dayRuler];
    sunTimes.textContent = `Sunrise ${fmt(state.sunrise)} • Sunset ${fmt(state.sunset)} • Next sunrise ${fmt(state.nextSunrise)}`;

    // hour block
    hourPill.textContent = planetGlyphName(cur.planet);
    phaseBadge.textContent = cur.phase;
    hourFocus.textContent = HOUR_FOCUS[cur.planet];

    // ordinals + harmonic (display only)
    const ord = state.ordMap[idx] || 1;
    ordinalChip.textContent = `${ORDINAL_LABEL[ord]} (${HARMONIC[ord]})`;
    harmonicNote.textContent = HARMONIC[ord] || "—";

    // n/24, hours ruled chips
    hourOfDayChip.textContent = `Hour ${idx}/24`;
    const st = state.stats[cur.planet];
    hoursRuledChip.textContent = `Hours ruled: ${st.B}B/${st.D}D/${st.T}T`;

    // multiplier
    const mult = multiplier(state.dayRuler, cur.planet);
    multBig.textContent = `x${mult.toFixed(3)}`;

    // bridge info (last dark of today → first bright of next day)
    const lastDark = state.schedule.find(h=>h.idx===24);
    const firstBright = state.schedule.find(h=>h.idx===1);
    const m1 = multiplier(state.dayRuler, lastDark.planet);
    const nextDayRuler = DAY_RULER[(startOfLocalDay(state.nextSunrise).getDay())];
    const m2 = multiplier(nextDayRuler, firstBright.planet);
    const delta = (m2 - m1);
    bridgeInfo.innerHTML =
      `Bridge hour <span class="mono">${fmt(lastDark.start)}–${fmt(lastDark.end)}</span> \
       last dark ruler: <strong>${GLYPH[lastDark.planet]} ${lastDark.planet}</strong> (×${m1.toFixed(3)}). \
       Next day first ruler: <strong>${GLYPH[firstBright.planet]} ${firstBright.planet}</strong> \
       on ${nextDayRuler} day (×${m2.toFixed(3)}). \
       Δ at daybreak: <span class="${delta>=0?'good':'bad'} mono">${delta>=0?'+':''}${delta.toFixed(3)}</span>`;
  }

  function paintTable(){
    weekdayBanner.textContent = `${state.weekdayName} ruled by ${state.dayRuler}`;
    hoursTableBody.innerHTML = "";
    state.schedule.forEach(h=>{
      const tr = document.createElement('tr');
      const ord = state.ordMap[h.idx] || 1;
      if (hourAt(getNow().getTime()).idx === h.idx) tr.classList.add('now');

      const m = multiplier(state.dayRuler, h.planet);

      const st = state.stats[h.planet];
      const focus = HOUR_FOCUS[h.planet];

      tr.innerHTML = `
        <td class="mono">${h.idx} <span class="tiny subpill">${h.phase}</span></td>
        <td class="mono">${fmt(h.start)}</td>
        <td class="mono">${fmt(h.end)}</td>
        <td>${GLYPH[h.planet]} ${h.planet}</td>
        <td class="mono">${ORDINAL_LABEL[ord]} (${HARMONIC[ord]})</td>
        <td class="mono">${h.idx}/24</td>
        <td class="mono">${st.B} / ${st.D} / ${st.T}</td>
        <td class="mono">x${m.toFixed(3)}</td>
        <td>${focus}</td>
      `;
      hoursTableBody.appendChild(tr);
    });
  }

  function paintMatrix(){
    // header
    mxHead.innerHTML = `<th>Hour ↓ / Day →</th>` +
      ORDER.map(d=>`<th>${GLYPH[d]} ${d}</th>`).join('');
    // rows: for matrix readability, use ORDER as hour rulers top-to-bottom
    mxBody.innerHTML="";
    ORDER.forEach(hr=>{
      const tr=document.createElement('tr');
      tr.innerHTML = `<td><strong>${GLYPH[hr]} ${hr}</strong></td>` +
        ORDER.map(day => `<td class="tiny">${MATRIX_BLURB(hr,day)}</td>`).join('');
      mxBody.appendChild(tr);
    });
  }

  function paintWeeklyBridges(){
    bridgesBody.innerHTML = "";
    // simulate 7 days from current anchor
    let anchor0 = startOfLocalDay(state.sunrise); // current anchor date
    for(let k=0;k<7;k++){
      const curBuilt = buildSchedule(anchor0, state.lat, state.lon);
      const nextAnchor = new Date(anchor0); nextAnchor.setDate(nextAnchor.getDate()+1);
      const nextBuilt = buildSchedule(nextAnchor, state.lat, state.lon);

      const lastDark = curBuilt.list.find(h=>h.idx===24);
      const firstBright = nextBuilt.list.find(h=>h.idx===1);

      const dayR = curBuilt.dayRuler;
      const nextDayR = nextBuilt.dayRuler;
      const m1 = multiplier(dayR, lastDark.planet);
      const m2 = multiplier(nextDayR, firstBright.planet);
      const delta = m2-m1;

      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>${curBuilt.weekdayName}</td>
        <td class="mono">${GLYPH[lastDark.planet]} ${lastDark.planet} ×${m1.toFixed(3)}</td>
        <td>${WEEKDAY_NAME[(startOfLocalDay(nextBuilt.sunrise).getDay())]}</td>
        <td class="mono">${GLYPH[firstBright.planet]} ${firstBright.planet} ×${m2.toFixed(3)}</td>
        <td class="mono ${delta>=0?'good':'bad'}">${delta>=0?'+':''}${delta.toFixed(3)}</td>
      `;
      // highlight Venus→Saturn jump
      if (lastDark.planet==="Moon" && nextDayR==="Saturn") tr.style.background="#fff4f0";
      bridgesBody.appendChild(tr);

      anchor0 = nextAnchor;
    }
  }

  // --------- Controls
  function applyInputsToState(){
    state.lat = parseFloat(latIn.value);
    state.lon = parseFloat(lonIn.value);
    state.tzMode = tzSel.value;
    // manual date/time
    const d = dateSel.value, t = timeSel.value;
    if (d && t){
      const [yy,mm,dd] = d.split('-').map(Number);
      const [hh,mi] = t.split(':').map(Number);
      const dt = new Date(yy, mm-1, dd, hh, mi, 0);
      state.manual = dt;
    }
  }

  geoBtn.onclick = () => {
    if(!navigator.geolocation){ alert("Geolocation not supported."); return; }
    navigator.geolocation.getCurrentPosition(
      pos => { latIn.value = pos.coords.latitude.toFixed(6); lonIn.value = pos.coords.longitude.toFixed(6); applyInputsToState(); rebuild(); },
      err => alert("Location error: "+err.message),
      { enableHighAccuracy:true, timeout:10000, maximumAge:60000 }
    );
  };

  setLL.onclick = () => { applyInputsToState(); rebuild(); };
  tzSel.onchange = () => { applyInputsToState(); rebuild(); };
  nowBtn.onclick = () => { state.manual = null; rebuild(); };
  applyBtn.onclick = () => { applyInputsToState(); rebuild(); };

  copyLinkBtn.onclick = () => {
    // encode lat,lon,tz,manual
    const params = new URLSearchParams();
    params.set("lat", state.lat.toFixed(6));
    params.set("lon", state.lon.toFixed(6));
    params.set("tz", state.tzMode);
    if (state.manual){
      params.set("dt", state.manual.toISOString());
    }
    const url = `${location.origin}${location.pathname}?${params.toString()}`;
    navigator.clipboard.writeText(url).then(()=> { copyLinkBtn.textContent="Copied!"; setTimeout(()=>copyLinkBtn.textContent="Copy link to this view",1200); });
  };

  // --------- Init & deep link
  function initFromQuery(){
    try{
      const q = new URLSearchParams(location.search);
      const lat = parseFloat(q.get("lat")), lon = parseFloat(q.get("lon"));
      if (!Number.isNaN(lat) && !Number.isNaN(lon)){ state.lat=lat; state.lon=lon; }
      const tz = q.get("tz"); if (tz) state.tzMode = tz;
      const dt = q.get("dt"); if (dt) state.manual = new Date(dt);
    }catch{}
    latIn.value = state.lat.toFixed(6);
    lonIn.value = state.lon.toFixed(6);
    tzSel.value = state.tzMode;
    const now = getNow();
    dateSel.value = now.toISOString().slice(0,10);
    timeSel.value = `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
  }

  function tick(){
    updateClock();
    // only animate if we're in the current hour block
    const now = getNow().getTime();
    const cur = hourAt(now);
    if (cur){
      const dur = cur.end - cur.start;
      const remain = cur.end.getTime() - now;
      const prog = clamp(100*(1-remain/dur),0,100);
      tickerFill.style.width = `${prog}%`;
      const mm = Math.floor(remain/60000), ss = Math.floor((remain%60000)/1000);
      countdownEl.textContent = `Next in ${pad2(mm)}:${pad2(ss)}`;
    }
    requestAnimationFrame(tick);
  }

  // Boot
  initFromQuery();
  rebuild();
  tick();

})();
</script>
</body>
</html>
